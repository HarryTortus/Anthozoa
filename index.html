<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anthozoa</title>
    
    <!-- Import the p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    
    <!-- Import Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap" rel="stylesheet">

    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="anthozoa.css">
    
</head>
<body>
    <h1 class="main-title">Anthozoa</h1>
    <p class="subtitle">Click on the canvas to plant a seed.</p>


    <div id="sketch-container">
        <div id="p5-canvas-placeholder"></div>
    </div>
    
    <div class="controls">
        <div class="control-wrapper">
            <div class="control-group">
                <label for="repelDist">Repulsion</label>
                <input type="range" id="repelDist" min="10" max="150" value="50" step="1">
                <span class="value-display" id="repelDist-value">50</span>
            </div>
            <div class="control-group">
                <label for="growthThreshold">Growth</label>
                <input type="range" id="growthThreshold" min="5" max="40" value="28" step="1">
                <span class="value-display" id="growthThreshold-value">66</span>
            </div>
            <div class="control-group">
                <label for="noiseAmount">Wander</label>
                <input type="range" id="noiseAmount" min="0" max="1.5" value="0.5" step="0.05">
                <span class="value-display" id="noiseAmount-value">33</span>
            </div>
            <div class="control-group">
                <label for="strokeWidth">Thickness</label>
                <input type="range" id="strokeWidth" min="1" max="10" value="2" step="0.5">
                <span class="value-display" id="strokeWidth-value">11</span>
            </div>
            <!-- Visual effect controls are now grouped together -->
            <div class="control-group">
                 <button id="fill-btn">Fill: OFF</button>
                 <label for="fillOpacity" style="margin-left:15px;">Opacity</label>
                 <input type="range" id="fillOpacity" min="0" max="1" value="0.4" step="0.01" disabled>
                 <span class="value-display" id="fillOpacity-value">40</span>
            </div>
             <div class="control-group">
                 <button id="wall-repel-btn">Boundaries: OFF</button>
                <label for="boundaryMargin" style="margin-left:15px;">Margin</label>
                <input type="range" id="boundaryMargin" min="1" max="150" value="50" step="1" disabled>
                <span class="value-display" id="boundaryMargin-value">33</span>
            </div>
            <div class="control-group">
                <label for="bgColorPicker">Background</label>
                <input type="color" id="bgColorPicker" value="#ffffff">
            </div>
             <div class="control-group action-buttons">
                <button id="pause-btn">Pause</button>
                <button id="clear-btn">Clear Canvas</button>
                <button id="save-btn">Save Canvas</button>
            </div>
        </div>
    </div>

    <footer id="site-footer">
        <span><a href="https://www.mickeywilliamson3d.com/" target="_blank" rel="noopener noreferrer">Mickey Williamson</a></span>
        <span>|</span>
        <span><a href="https://harrytortus.github.io/" target="_blank" rel="noopener noreferrer">Harry Tortus</a></span>
        <span>|</span>
        <span id="version-number">v0.20</span>
    </footer>


    <script>
        // === GLOBAL PARAMETERS === //
        let PARAMS = {
            repelDist: 50,
            growthThreshold: 28,
            simplificationThreshold: 1, // Hardcoded for best results.
            noiseAmount: 0.5,
            strokeWidth: 2,
            wallRepel: false,
            boundaryMargin: 50,
            fillLoops: false,
            fillOpacity: 0.4, 
            initialPoints: 10,
            initialRadius: 15,
        };

        let allLoops = [];
        let noiseOffset = 0;
        let bgColor;
        let isPaused = false;
        let quadtree;
        
        // === OPTIMIZATION: QUADTREE IMPLEMENTATION === //
        class Point {
            constructor(x, y, owner) { this.x = x; this.y = y; this.owner = owner; }
        }
        class Rectangle {
            constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
            contains(point) { return (point.x >= this.x - this.w && point.x < this.x + this.w && point.y >= this.y - this.h && point.y < this.y + this.h); }
            intersects(range) { let xDist = Math.abs(range.x - this.x); let yDist = Math.abs(range.y - this.y); let r = range.r; let w = this.w; let h = this.h; let edges = Math.pow(xDist - w, 2) + Math.pow(yDist - h, 2); if (xDist > (r + w) || yDist > (r + h)) return false; if (xDist <= w || yDist <= h) return true; return edges <= r * r; }
        }
        class QuadTree {
            constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; }
            subdivide() { let x = this.boundary.x; let y = this.boundary.y; let w = this.boundary.w / 2; let h = this.boundary.h / 2; let ne = new Rectangle(x + w, y - h, w, h); this.northeast = new QuadTree(ne, this.capacity); let nw = new Rectangle(x - w, y - h, w, h); this.northwest = new QuadTree(nw, this.capacity); let se = new Rectangle(x + w, y + h, w, h); this.southeast = new QuadTree(se, this.capacity); let sw = new Rectangle(x - w, y + h, w, h); this.southwest = new QuadTree(sw, this.capacity); this.divided = true; }
            insert(point) { if (!this.boundary.contains(point)) { return false; } if (this.points.length < this.capacity) { this.points.push(point); return true; } if (!this.divided) { this.subdivide(); } this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point); }
            query(range, found) { if (!found) { found = []; } if (!this.boundary.intersects(range)) { return found; } for (let p of this.points) { const d = Math.sqrt(Math.pow(p.x - range.x, 2) + Math.pow(p.y - range.y, 2)); if (d < range.r) { found.push(p); } } if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); } return found; }
        }

        // === p5.js SKETCH === //
        class AnthozoaLoop {
            constructor(x, y) {
                this.points = [];
                this.hue = random(360);
                this.noiseSeed = random(1000);

                for (let i = 0; i < PARAMS.initialPoints; i++) {
                    let angle = map(i, 0, PARAMS.initialPoints, 0, TWO_PI);
                    let px = x + cos(angle) * PARAMS.initialRadius;
                    let py = y + sin(angle) * PARAMS.initialRadius;
                    this.points.push(createVector(px, py));
                }
            }

            update() {
                this.movePoints();
                this.grow();
                this.simplify();
            }

            grow() {
                // To make the UI slider intuitive (high value = more growth),
                // we map the parameter to an inverted threshold for the logic.
                // A high slider value gives a low threshold, causing more growth.
                const growthSlider = document.getElementById('growthThreshold');
                const minThreshold = Number(growthSlider.min);
                const maxThreshold = Number(growthSlider.max);
                let invertedThreshold = map(PARAMS.growthThreshold, minThreshold, maxThreshold, maxThreshold, minThreshold);
                
                for (let i = this.points.length - 1; i >= 0; i--) {
                    let p1 = this.points[i];
                    let p2 = this.points[(i + 1) % this.points.length];
                    let d = p5.Vector.dist(p1, p2);

                    if (d > invertedThreshold) {
                        let midPoint = p5.Vector.lerp(p1, p2, 0.5);
                        this.points.splice(i + 1, 0, midPoint);
                    }
                }
            }
            
            simplify() {
                if (this.points.length <= PARAMS.initialPoints) return;

                for (let i = this.points.length - 1; i >= 0; i--) {
                    let p1 = this.points[i];
                    let p2 = this.points[(i + 1) % this.points.length];
                    let d = p5.Vector.dist(p1, p2);
                    if (d < PARAMS.simplificationThreshold) {
                         this.points.splice(i, 1);
                    }
                }
            }

            movePoints() {
                let newPositions = [];
                for (let i = 0; i < this.points.length; i++) {
                    let p = this.points[i];
                    
                    let repulsion = this.getRepulsionVector(p);
                    repulsion.mult(2.0);

                    let noiseForce = this.getNoiseVector(p);
                    noiseForce.mult(PARAMS.noiseAmount);
                    
                    let prev = this.points[(i - 1 + this.points.length) % this.points.length];
                    let next = this.points[(i + 1) % this.points.length];
                    let desiredMidpoint = p5.Vector.lerp(prev, next, 0.5);
                    let smoothingForce = p5.Vector.sub(desiredMidpoint, p);
                    smoothingForce.mult(0.1);

                    let wallRepulsion = createVector(0, 0);
                    if (PARAMS.wallRepel) {
                        let boundaryDist = PARAMS.boundaryMargin;
                        let wallForceStrength = 0.1;

                        if (p.x < boundaryDist)       wallRepulsion.x += wallForceStrength * (boundaryDist - p.x);
                        if (p.x > width - boundaryDist) wallRepulsion.x -= wallForceStrength * (p.x - (width - boundaryDist));
                        if (p.y < boundaryDist)       wallRepulsion.y += wallForceStrength * (boundaryDist - p.y);
                        if (p.y > height - boundaryDist) wallRepulsion.y -= wallForceStrength * (p.y - (height - boundaryDist));
                    }
                    
                    let totalForce = createVector();
                    totalForce.add(repulsion)
                              .add(noiseForce)
                              .add(smoothingForce)
                              .add(wallRepulsion);

                    let newPos = p5.Vector.add(p, totalForce);

                    if (PARAMS.wallRepel) {
                        newPos.x = constrain(newPos.x, 0, width);
                        newPos.y = constrain(newPos.y, 0, height);
                    }

                    newPositions.push(newPos);
                }
                this.points = newPositions;
            }

            getNoiseVector(point) {
                let angle = noise(point.x * 0.01, point.y * 0.01, this.noiseSeed + noiseOffset) * TWO_PI * 2;
                return p5.Vector.fromAngle(angle);
            }

            getRepulsionVector(point) {
                let totalRepulsion = createVector(0, 0);
                let range = { x: point.x, y: point.y, r: PARAMS.repelDist };
                let neighbors = quadtree.query(range);

                for (const otherPoint of neighbors) {
                    if (point.x === otherPoint.x && point.y === otherPoint.y) continue;
                    let d = dist(point.x, point.y, otherPoint.x, otherPoint.y);
                    if (d > 0 && d < PARAMS.repelDist) {
                        let repel = p5.Vector.sub(point, createVector(otherPoint.x, otherPoint.y));
                        repel.normalize();
                        repel.div(d);
                        totalRepulsion.add(repel);
                    }
                }
                return totalRepulsion;
            }

            display() {
                if (this.points.length < 3) return;

                let strokeColor = color(this.hue, 80, 85);
                
                if (PARAMS.fillLoops) {
                    let fillColor = color(this.hue, 80, 85, PARAMS.fillOpacity);
                    fill(fillColor);
                } else {
                    noFill();
                }
                stroke(strokeColor);
                strokeWeight(PARAMS.strokeWidth);

                beginShape();
                curveVertex(this.points[this.points.length - 1].x, this.points[this.points.length - 1].y);
                for (let i = 0; i < this.points.length; i++) {
                    curveVertex(this.points[i].x, this.points[i].y);
                }
                curveVertex(this.points[0].x, this.points[0].y);
                curveVertex(this.points[1].x, this.points[1].y);
                endShape();
            }
        }

        // === p5.js Core Functions === //
        
        function getCanvasSize() {
             const sketchContainer = document.getElementById('sketch-container');
             const availableWidth = sketchContainer.clientWidth;
             const availableHeight = sketchContainer.clientHeight;
             return min(availableWidth, availableHeight);
        }

        function setup() {
            let canvasSize = getCanvasSize();
            const canvas = createCanvas(canvasSize, canvasSize);
            canvas.parent('p5-canvas-placeholder');
            colorMode(HSB, 360, 100, 100, 1);
            
            bgColor = color(document.getElementById('bgColorPicker').value);
            background(bgColor); 
            
            setupControls();
        }
        
        function setupControls() {
            const sliders = document.querySelectorAll('input[type="range"]');
            sliders.forEach(slider => {
                // Function to update the display for a slider
                const updateDisplay = () => {
                    const id = slider.id;
                    const value = Number(slider.value);
                    const min = Number(slider.min);
                    const max = Number(slider.max);
                    
                    // All sliders are now mapped from 0-100 for the UI
                    let displayValue = map(value, min, max, 0, 100);

                    const valueSpan = document.getElementById(`${id}-value`);
                    if (valueSpan) {
                         valueSpan.textContent = floor(displayValue);
                    }
                };

                // Update display on input
                slider.addEventListener('input', (e) => {
                    PARAMS[e.target.id] = Number(e.target.value);
                    updateDisplay();
                    updateSliderTrack(e.target);
                });

                // Set initial display value
                updateDisplay();
                updateSliderTrack(slider);
            });


            document.getElementById('bgColorPicker').addEventListener('input', (e) => {
                bgColor = color(e.target.value);
                background(bgColor);
            });

            document.getElementById('clear-btn').addEventListener('click', () => { 
                allLoops = []; 
                background(bgColor); 
            });
            
            const pauseBtn = document.getElementById('pause-btn');
            pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                if (isPaused) { noLoop(); pauseBtn.textContent = 'Play'; } else { loop(); pauseBtn.textContent = 'Pause'; }
            });
            
            const fillBtn = document.getElementById('fill-btn');
            const fillOpacitySlider = document.getElementById('fillOpacity');
            fillBtn.addEventListener('click', () => {
                PARAMS.fillLoops = !PARAMS.fillLoops;
                fillBtn.textContent = `Fill: ${PARAMS.fillLoops ? 'ON' : 'OFF'}`;
                fillOpacitySlider.disabled = !PARAMS.fillLoops;
            });

            const wallRepelBtn = document.getElementById('wall-repel-btn');
            const boundaryMarginSlider = document.getElementById('boundaryMargin');
            wallRepelBtn.addEventListener('click', () => {
                PARAMS.wallRepel = !PARAMS.wallRepel;
                wallRepelBtn.textContent = `Boundaries: ${PARAMS.wallRepel ? 'ON' : 'OFF'}`;
                boundaryMarginSlider.disabled = !PARAMS.wallRepel;
            });

            document.getElementById('save-btn').addEventListener('click', () => {
                saveCanvas('anthozoa', 'png');
            });
        }
        
        function updateSliderTrack(slider) {
            const min = slider.min || 0; const max = slider.max || 100; const value = slider.value;
            const progress = ((value - min) / (max - min)) * 100;
            slider.style.setProperty('--range-progress', `${progress}%`);
        }

        function draw() {
            let trailColor = color(bgColor.toString());
            trailColor.setAlpha(25);
            background(trailColor);
            
            let boundary = new Rectangle(width / 2, height / 2, width / 2, height / 2);
            quadtree = new QuadTree(boundary, 4);
            for (let loop of allLoops) {
                for (let p of loop.points) {
                    quadtree.insert(new Point(p.x, p.y));
                }
            }
            for (let loop of allLoops) { loop.update(); loop.display(); }
            noiseOffset += 0.002;
        }

        function mousePressed() {
            if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
                if (isPaused) return;
                allLoops.push(new AnthozoaLoop(mouseX, mouseY));
            }
        }

        function touchStarted() {
            if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
                if (isPaused) return;
                allLoops.push(new AnthozoaLoop(mouseX, mouseY));
                return false; 
            }
        }

        function windowResized() {
            let canvasSize = getCanvasSize();
            resizeCanvas(canvasSize, canvasSize);
            background(bgColor);
        }

    </script>
</body>
</html>
