<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anthozoa</title>
    
    <!-- Import the p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    
    <!-- Import Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap" rel="stylesheet">

    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="anthozoa.css">
    
</head>
<body>
    <h1 class="main-title">Anthozoa</h1>
    <p class="subtitle">Click on the canvas to plant a seed.</p>


    <div id="sketch-container">
        <div id="p5-canvas-placeholder"></div>
    </div>
    
    <div class="controls">
        <div class="control-wrapper">
            <div class="control-group">
                <label for="repelDist">Repulsion</label>
                <input type="range" id="repelDist" min="10" max="150" value="122" step="1">
                <span class="value-display" id="repelDist-value">80</span>
            </div>
            <div class="control-group">
                <label for="growthRate">Growth</label>
                <input type="range" id="growthRate" min="0" max="100" value="80" step="1">
                <span class="value-display" id="growthRate-value">80</span>
            </div>
            <div class="control-group">
                <label for="noiseAmount">Wander</label>
                <input type="range" id="noiseAmount" min="0" max="1.5" value="0.6" step="0.05">
                <span class="value-display" id="noiseAmount-value">40</span>
            </div>
            <div class="control-group">
                <label for="strokeWidth">Thickness</label>
                <input type="range" id="strokeWidth" min="1" max="10" value="1" step="0.5">
                <span class="value-display" id="strokeWidth-value">0</span>
            </div>
            <!-- Visual effect controls are now grouped together -->
            <div class="control-group">
                 <button id="fill-btn">Fill: ON</button>
                 <label for="fillOpacity" style="margin-left:15px;">Opacity</label>
                 <input type="range" id="fillOpacity" min="0" max="1" value="0.5" step="0.01">
                 <span class="value-display" id="fillOpacity-value">50</span>
            </div>
             <div class="control-group">
                 <button id="wall-repel-btn">Boundaries: ON</button>
                <label for="boundaryMargin" style="margin-left:15px;">Margin</label>
                <input type="range" id="boundaryMargin" min="0" max="100" value="0" step="1">
                <span class="value-display" id="boundaryMargin-value">0</span>
            </div>
            <div class="control-group">
                <label for="bgColorPicker">Background</label>
                <input type="color" id="bgColorPicker" value="#ffffff">
            </div>
             <div class="control-group action-buttons">
                <button id="pause-btn">Pause</button>
                <button id="clear-btn">Clear Canvas</button>
                <button id="save-btn">Save Canvas</button>
            </div>
        </div>
    </div>

    <footer id="site-footer">
        <span><a href="https://www.mickeywilliamson3d.com/" target="_blank" rel="noopener noreferrer">Mickey Williamson</a></span>
        <span>|</span>
        <span><a href="https://harrytortus.github.io/" target="_blank" rel="noopener noreferrer">Harry Tortus</a></span>
        <span>|</span>
        <span id="version-number">v0.33</span>
    </footer>


    <script>
        // Use window.onload to ensure all CSS and elements are loaded before we run the script
        window.onload = function() {
            
            // --- p5.js Sketch running in "Instance Mode" --- //
            const sketch = (p) => {

                // === GLOBAL PARAMETERS === //
                let PARAMS = {
                    repelDist: 122,
                    growthRate: 80, 
                    simplificationThreshold: 1, 
                    noiseAmount: 0.6,
                    strokeWidth: 1,
                    wallRepel: true,
                    boundaryMargin: 0, 
                    fillLoops: true,
                    fillOpacity: 0.5, 
                    initialPoints: 10,
                    initialRadius: 15,
                };

                let allLoops = [];
                let noiseOffset = 0;
                let bgColor;
                let isPaused = false;
                let quadtree;
                
                // === OPTIMIZATION: QUADTREE IMPLEMENTATION === //
                class Point {
                    constructor(x, y, owner) { this.x = x; this.y = y; this.owner = owner; }
                }
                class Rectangle {
                    constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
                    contains(point) { return (point.x >= this.x - this.w && point.x < this.x + this.w && point.y >= this.y - this.h && point.y < this.y + this.h); }
                    intersects(range) { let xDist = Math.abs(range.x - this.x); let yDist = Math.abs(range.y - this.y); let r = range.r; let w = this.w; let h = this.h; let edges = Math.pow(xDist - w, 2) + Math.pow(yDist - h, 2); if (xDist > (r + w) || yDist > (r + h)) return false; if (xDist <= w || yDist <= h) return true; return edges <= r * r; }
                }
                class QuadTree {
                    constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; }
                    subdivide() { let x = this.boundary.x; let y = this.boundary.y; let w = this.boundary.w / 2; let h = this.boundary.h / 2; let ne = new Rectangle(x + w, y - h, w, h); this.northeast = new QuadTree(ne, this.capacity); let nw = new Rectangle(x - w, y - h, w, h); this.northwest = new QuadTree(nw, this.capacity); let se = new Rectangle(x + w, y + h, w, h); this.southeast = new QuadTree(se, this.capacity); let sw = new Rectangle(x - w, y + h, w, h); this.southwest = new QuadTree(sw, this.capacity); this.divided = true; }
                    insert(point) { if (!this.boundary.contains(point)) { return false; } if (this.points.length < this.capacity) { this.points.push(point); return true; } if (!this.divided) { this.subdivide(); } this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point); }
                    query(range, found) { if (!found) { found = []; } if (!this.boundary.intersects(range)) { return found; } for (let pt of this.points) { const d = Math.sqrt(Math.pow(pt.x - range.x, 2) + Math.pow(pt.y - range.y, 2)); if (d < range.r) { found.push(pt); } } if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); } return found; }
                }

                // === p5.js SKETCH === //
                class AnthozoaLoop {
                    constructor(x, y) {
                        this.points = [];
                        this.hue = p.random(360);
                        this.noiseSeed = p.random(1000);

                        for (let i = 0; i < PARAMS.initialPoints; i++) {
                            let angle = p.map(i, 0, PARAMS.initialPoints, 0, p.TWO_PI);
                            let px = x + p.cos(angle) * PARAMS.initialRadius;
                            let py = y + p.sin(angle) * PARAMS.initialRadius;
                            this.points.push(p.createVector(px, py));
                        }
                    }

                    update() {
                        this.movePoints();
                        this.grow();
                        this.simplify();
                    }

                    grow() {
                        let logicThreshold = p.map(PARAMS.growthRate, 0, 100, 40, 5);
                        
                        for (let i = this.points.length - 1; i >= 0; i--) {
                            let p1 = this.points[i];
                            let p2 = this.points[(i + 1) % this.points.length];
                            let d = p5.Vector.dist(p1, p2);

                            if (d > logicThreshold) {
                                let midPoint = p5.Vector.lerp(p1, p2, 0.5);
                                this.points.splice(i + 1, 0, midPoint);
                            }
                        }
                    }
                    
                    simplify() {
                        if (this.points.length <= PARAMS.initialPoints) return;

                        for (let i = this.points.length - 1; i >= 0; i--) {
                            let p1 = this.points[i];
                            let p2 = this.points[(i + 1) % this.points.length];
                            let d = p5.Vector.dist(p1, p2);
                            if (d < PARAMS.simplificationThreshold) {
                                 this.points.splice(i, 1);
                            }
                        }
                    }

                    movePoints() {
                        let newPositions = [];
                        for (let i = 0; i < this.points.length; i++) {
                            let pt = this.points[i];
                            
                            let repulsion = this.getRepulsionVector(pt);
                            repulsion.mult(2.0);

                            let noiseForce = this.getNoiseVector(pt);
                            noiseForce.mult(PARAMS.noiseAmount);
                            
                            let prev = this.points[(i - 1 + this.points.length) % this.points.length];
                            let next = this.points[(i + 1) % this.points.length];
                            let desiredMidpoint = p5.Vector.lerp(prev, next, 0.5);
                            let smoothingForce = p5.Vector.sub(desiredMidpoint, pt);
                            smoothingForce.mult(0.1);

                            let wallRepulsion = p.createVector(0, 0);
                            if (PARAMS.wallRepel) {
                                let marginPercent = p.map(PARAMS.boundaryMargin, 0, 100, 0.04, 0.5);
                                let boundaryDist = p.width * marginPercent;
                                let wallForceStrength = 0.1;

                                if (pt.x < boundaryDist)       wallRepulsion.x += wallForceStrength * (boundaryDist - pt.x);
                                if (pt.x > p.width - boundaryDist) wallRepulsion.x -= wallForceStrength * (pt.x - (p.width - boundaryDist));
                                if (pt.y < boundaryDist)       wallRepulsion.y += wallForceStrength * (boundaryDist - pt.y);
                                if (pt.y > p.height - boundaryDist) wallRepulsion.y -= wallForceStrength * (pt.y - (p.height - boundaryDist));
                            }
                            
                            let totalForce = p.createVector();
                            totalForce.add(repulsion)
                                      .add(noiseForce)
                                      .add(smoothingForce)
                                      .add(wallRepulsion);

                            let newPos = p5.Vector.add(pt, totalForce);

                            if (PARAMS.wallRepel) {
                                newPos.x = p.constrain(newPos.x, 0, p.width);
                                newPos.y = p.constrain(newPos.y, 0, p.height);
                            }

                            newPositions.push(newPos);
                        }
                        this.points = newPositions;
                    }

                    getNoiseVector(point) {
                        let angle = p.noise(point.x * 0.01, point.y * 0.01, this.noiseSeed + noiseOffset) * p.TWO_PI * 2;
                        return p5.Vector.fromAngle(angle);
                    }

                    getRepulsionVector(point) {
                        let totalRepulsion = p.createVector(0, 0);
                        let range = { x: point.x, y: point.y, r: PARAMS.repelDist };
                        let neighbors = quadtree.query(range);

                        for (const otherPoint of neighbors) {
                            if (point.x === otherPoint.x && point.y === otherPoint.y) continue;
                            let d = p.dist(point.x, point.y, otherPoint.x, otherPoint.y);
                            if (d > 0 && d < PARAMS.repelDist) {
                                let repel = p5.Vector.sub(point, p.createVector(otherPoint.x, otherPoint.y));
                                repel.normalize();
                                repel.div(d);
                                totalRepulsion.add(repel);
                            }
                        }
                        return totalRepulsion;
                    }

                    display() {
                        if (this.points.length < 3) return;

                        let strokeColor = p.color(this.hue, 80, 85);
                        
                        if (PARAMS.fillLoops) {
                            let fillColor = p.color(this.hue, 80, 85, PARAMS.fillOpacity);
                            p.fill(fillColor);
                        } else {
                            p.noFill();
                        }
                        p.stroke(strokeColor);
                        p.strokeWeight(PARAMS.strokeWidth);

                        p.beginShape();
                        p.curveVertex(this.points[this.points.length - 1].x, this.points[this.points.length - 1].y);
                        for (let pt of this.points) {
                            p.curveVertex(pt.x, pt.y);
                        }
                        p.curveVertex(this.points[0].x, this.points[0].y);
                        p.curveVertex(this.points[1].x, this.points[1].y);
                        p.endShape();
                    }
                }

                // --- Helper Functions ---
                
                const getCanvasSize = () => {
                     const sketchContainer = document.getElementById('sketch-container');
                     const availableWidth = sketchContainer.clientWidth;
                     const availableHeight = sketchContainer.clientHeight;
                     return Math.min(availableWidth, availableHeight);
                }

                const redrawStatic = () => {
                    p.background(bgColor);
                    for (let loop of allLoops) {
                        loop.display();
                    }
                }

                const setupControls = () => {
                    const sliders = document.querySelectorAll('input[type="range"]');
                    sliders.forEach(slider => {
                        const updateDisplay = () => {
                            const id = slider.id;
                            const value = Number(slider.value);
                            const min = Number(slider.min);
                            const max = Number(slider.max);
                            
                            let displayValue = p.map(value, min, max, 0, 100);

                            const valueSpan = document.getElementById(`${id}-value`);
                            if (valueSpan) {
                                 valueSpan.textContent = p.floor(displayValue);
                            }
                        };

                        slider.addEventListener('input', (e) => {
                            PARAMS[e.target.id] = Number(e.target.value);
                            updateDisplay();
                            updateSliderTrack(e.target);
                            if (isPaused && ['strokeWidth', 'fillOpacity', 'boundaryMargin'].includes(e.target.id)) {
                                redrawStatic();
                            }
                        });

                        updateDisplay();
                        updateSliderTrack(slider);
                    });


                    document.getElementById('bgColorPicker').addEventListener('input', (e) => {
                        bgColor = p.color(e.target.value);
                        if (isPaused) {
                            redrawStatic();
                        } else {
                            p.background(bgColor);
                        }
                    });

                    document.getElementById('clear-btn').addEventListener('click', () => { 
                        allLoops = []; 
                        if(isPaused) redrawStatic();
                        else p.background(bgColor); 
                    });
                    
                    const pauseBtn = document.getElementById('pause-btn');
                    pauseBtn.addEventListener('click', () => {
                        isPaused = !isPaused;
                        if (isPaused) { p.noLoop(); pauseBtn.textContent = 'Play'; } else { p.loop(); pauseBtn.textContent = 'Pause'; }
                    });
                    
                    const fillBtn = document.getElementById('fill-btn');
                    const fillOpacitySlider = document.getElementById('fillOpacity');
                    fillBtn.addEventListener('click', () => {
                        PARAMS.fillLoops = !PARAMS.fillLoops;
                        fillBtn.textContent = `Fill: ${PARAMS.fillLoops ? 'ON' : 'OFF'}`;
                        fillOpacitySlider.disabled = !PARAMS.fillLoops;
                        fillOpacitySlider.parentElement.classList.toggle('disabled-group', !PARAMS.fillLoops);
                        if (isPaused) redrawStatic();
                    });
                    fillOpacitySlider.parentElement.classList.toggle('disabled-group', !PARAMS.fillLoops);

                    const wallRepelBtn = document.getElementById('wall-repel-btn');
                    const boundaryMarginSlider = document.getElementById('boundaryMargin');
                    wallRepelBtn.addEventListener('click', () => {
                        PARAMS.wallRepel = !PARAMS.wallRepel;
                        wallRepelBtn.textContent = `Boundaries: ${PARAMS.wallRepel ? 'ON' : 'OFF'}`;
                        boundaryMarginSlider.disabled = !PARAMS.wallRepel;
                        boundaryMarginSlider.parentElement.classList.toggle('disabled-group', !PARAMS.wallRepel);
                         if (isPaused) redrawStatic();
                    });
                    boundaryMarginSlider.parentElement.classList.toggle('disabled-group', !PARAMS.wallRepel);

                    document.getElementById('save-btn').addEventListener('click', () => {
                        p.saveCanvas('anthozoa', 'png');
                    });
                }
                
                const updateSliderTrack = (slider) => {
                    const min = slider.min || 0; const max = slider.max || 100; const value = slider.value;
                    const progress = ((value - min) / (max - min)) * 100;
                    slider.style.setProperty('--range-progress', `${progress}%`);
                }
                
                // --- p5.js Core Functions attached to sketch instance "p" ---
                p.setup = () => {
                    let canvasSize = getCanvasSize();
                    const canvas = p.createCanvas(canvasSize, canvasSize);
                    canvas.parent('p5-canvas-placeholder');
                    p.colorMode(p.HSB, 360, 100, 100, 1);
                    
                    bgColor = p.color(document.getElementById('bgColorPicker').value);
                    p.background(bgColor); 
                    
                    setupControls();
                };

                p.draw = () => {
                    let trailColor = p.color(bgColor.toString());
                    trailColor.setAlpha(25);
                    p.background(trailColor);
                    
                    let boundary = new Rectangle(p.width / 2, p.height / 2, p.width / 2, p.height / 2);
                    quadtree = new QuadTree(boundary, 4);
                    for (let loop of allLoops) {
                        for (let pt of loop.points) {
                            quadtree.insert(new Point(pt.x, pt.y));
                        }
                    }
                    for (let loop of allLoops) { loop.update(); loop.display(); }
                    noiseOffset += 0.002;
                };

                p.mousePressed = () => {
                    if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                        if (isPaused) return;
                        allLoops.push(new AnthozoaLoop(p.mouseX, p.mouseY));
                    }
                };

                p.touchStarted = () => {
                    if (p.mouseX >= 0 && p.mouseX <= p.width && p.mouseY >= 0 && p.mouseY <= p.height) {
                        if (isPaused) return;
                        allLoops.push(new AnthozoaLoop(p.mouseX, p.mouseY));
                        return false; 
                    }
                };

                p.windowResized = () => {
                    let canvasSize = getCanvasSize();
                    p.resizeCanvas(canvasSize, canvasSize);
                    p.background(bgColor);
                    if(isPaused) redrawStatic();
                };
            };
            
            // Start the sketch
            new p5(sketch, 'p5-canvas-placeholder');
        };
    </script>
</body>
</html>
