<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anthozoa - Generative Growth</title>
    
    <!-- Import the p5.js library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
    
    <!-- Import Google Font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@400;700&display=swap" rel="stylesheet">

    <!-- Link to the external CSS file -->
    <link rel="stylesheet" href="anthozoa.css">

</head>
<body>
    <h1 class="main-title">Anthozoa</h1>

    <div id="sketch-container">
        <div id="p5-canvas-placeholder"></div>
    </div>
    
    <div class="controls">
        <div class="control-wrapper">
            <div class="control-group">
                <label for="repelDist">Repulsion</label>
                <input type="range" id="repelDist" min="10" max="150" value="50" step="1">
                <span class="value-display" id="repelDist-value">50</span>
            </div>
            <div class="control-group">
                <label for="growthThreshold">Growth</label>
                <input type="range" id="growthThreshold" min="5" max="40" value="12" step="1">
                <span class="value-display" id="growthThreshold-value">12</span>
            </div>
            <div class="control-group">
                <label for="noiseAmount">Wander</label>
                <input type="range" id="noiseAmount" min="0" max="1.5" value="0.5" step="0.05">
                <span class="value-display" id="noiseAmount-value">0.50</span>
            </div>
            <div class="control-group">
                <label for="strokeWidth">Thickness</label>
                <input type="range" id="strokeWidth" min="1" max="10" value="2" step="0.5">
                <span class="value-display" id="strokeWidth-value">2.0</span>
            </div>
             <div class="control-group action-buttons">
                <button id="pause-btn">Pause</button>
                <button id="clear-btn">Clear Canvas</button>
            </div>
        </div>
    </div>

    <footer id="site-footer">
        <span>Click on the canvas to plant a seed.</span>
    </footer>


    <script>
        // === GLOBAL PARAMETERS === //
        let PARAMS = {
            repelDist: 50,
            growthThreshold: 12,
            simplificationThreshold: 1, // REMOVED SLIDER: Hardcoded to 1 for best results.
            noiseAmount: 0.5,
            strokeWidth: 2,
            initialPoints: 10,
            initialRadius: 15,
        };

        let allLoops = [];
        let noiseOffset = 0;
        let bgColor;
        let isPaused = false;
        let quadtree;

        // === OPTIMIZATION: QUADTREE IMPLEMENTATION === //
        class Point {
            constructor(x, y, owner) { this.x = x; this.y = y; this.owner = owner; }
        }
        class Rectangle {
            constructor(x, y, w, h) { this.x = x; this.y = y; this.w = w; this.h = h; }
            contains(point) { return (point.x >= this.x - this.w && point.x < this.x + this.w && point.y >= this.y - this.h && point.y < this.y + this.h); }
            intersects(range) { let xDist = Math.abs(range.x - this.x); let yDist = Math.abs(range.y - this.y); let r = range.r; let w = this.w; let h = this.h; let edges = Math.pow(xDist - w, 2) + Math.pow(yDist - h, 2); if (xDist > (r + w) || yDist > (r + h)) return false; if (xDist <= w || yDist <= h) return true; return edges <= r * r; }
        }
        class QuadTree {
            constructor(boundary, capacity) { this.boundary = boundary; this.capacity = capacity; this.points = []; this.divided = false; }
            subdivide() { let x = this.boundary.x; let y = this.boundary.y; let w = this.boundary.w / 2; let h = this.boundary.h / 2; let ne = new Rectangle(x + w, y - h, w, h); this.northeast = new QuadTree(ne, this.capacity); let nw = new Rectangle(x - w, y - h, w, h); this.northwest = new QuadTree(nw, this.capacity); let se = new Rectangle(x + w, y + h, w, h); this.southeast = new QuadTree(se, this.capacity); let sw = new Rectangle(x - w, y + h, w, h); this.southwest = new QuadTree(sw, this.capacity); this.divided = true; }
            insert(point) { if (!this.boundary.contains(point)) { return false; } if (this.points.length < this.capacity) { this.points.push(point); return true; } if (!this.divided) { this.subdivide(); } this.northeast.insert(point) || this.northwest.insert(point) || this.southeast.insert(point) || this.southwest.insert(point); }
            query(range, found) { if (!found) { found = []; } if (!this.boundary.intersects(range)) { return found; } for (let p of this.points) { const d = Math.sqrt(Math.pow(p.x - range.x, 2) + Math.pow(p.y - range.y, 2)); if (d < range.r) { found.push(p); } } if (this.divided) { this.northwest.query(range, found); this.northeast.query(range, found); this.southwest.query(range, found); this.southeast.query(range, found); } return found; }
        }

        // === p5.js SKETCH === //
        class AnthozoaLoop {
            constructor(x, y) {
                this.points = [];
                this.hue = random(360);
                this.noiseSeed = random(1000);

                for (let i = 0; i < PARAMS.initialPoints; i++) {
                    let angle = map(i, 0, PARAMS.initialPoints, 0, TWO_PI);
                    let px = x + cos(angle) * PARAMS.initialRadius;
                    let py = y + sin(angle) * PARAMS.initialRadius;
                    this.points.push(createVector(px, py));
                }
            }

            update() {
                this.movePoints();
                this.grow();
                this.simplify();
            }

            grow() {
                for (let i = this.points.length - 1; i >= 0; i--) {
                    let p1 = this.points[i];
                    let p2 = this.points[(i + 1) % this.points.length];
                    let d = p5.Vector.dist(p1, p2);
                    if (d > PARAMS.growthThreshold) {
                        let midPoint = p5.Vector.lerp(p1, p2, 0.5);
                        this.points.splice(i + 1, 0, midPoint);
                    }
                }
            }
            
            simplify() {
                if (this.points.length <= PARAMS.initialPoints) return;

                for (let i = this.points.length - 1; i >= 0; i--) {
                    let p1 = this.points[i];
                    let p2 = this.points[(i + 1) % this.points.length];
                    let d = p5.Vector.dist(p1, p2);
                    if (d < PARAMS.simplificationThreshold) {
                         this.points.splice(i, 1);
                    }
                }
            }

            movePoints() {
                let newPositions = [];
                for (let i = 0; i < this.points.length; i++) {
                    let p = this.points[i];
                    let repulsion = this.getRepulsionVector(p);
                    repulsion.mult(2.0);
                    let noiseForce = this.getNoiseVector(p);
                    noiseForce.mult(PARAMS.noiseAmount);
                    let prev = this.points[(i - 1 + this.points.length) % this.points.length];
                    let next = this.points[(i + 1) % this.points.length];
                    let desiredMidpoint = p5.Vector.lerp(prev, next, 0.5);
                    let smoothingForce = p5.Vector.sub(desiredMidpoint, p);
                    smoothingForce.mult(0.1);
                    let totalForce = createVector();
                    totalForce.add(repulsion).add(noiseForce).add(smoothingForce);
                    let newPos = p5.Vector.add(p, totalForce);
                    newPositions.push(newPos);
                }
                this.points = newPositions;
            }

            getNoiseVector(point) {
                let angle = noise(point.x * 0.01, point.y * 0.01, this.noiseSeed + noiseOffset) * TWO_PI * 2;
                return p5.Vector.fromAngle(angle);
            }

            getRepulsionVector(point) {
                let totalRepulsion = createVector(0, 0);
                let range = { x: point.x, y: point.y, r: PARAMS.repelDist };
                let neighbors = quadtree.query(range);

                for (const otherPoint of neighbors) {
                    if (point.x === otherPoint.x && point.y === otherPoint.y) continue;
                    let d = dist(point.x, point.y, otherPoint.x, otherPoint.y);
                    if (d > 0 && d < PARAMS.repelDist) {
                        let repel = p5.Vector.sub(point, createVector(otherPoint.x, otherPoint.y));
                        repel.normalize();
                        repel.div(d);
                        totalRepulsion.add(repel);
                    }
                }
                return totalRepulsion;
            }

            display() {
                if (this.points.length < 3) return;
                stroke(this.hue, 80, 85);
                strokeWeight(PARAMS.strokeWidth);
                noFill();
                beginShape();
                curveVertex(this.points[this.points.length - 1].x, this.points[this.points.length - 1].y);
                for (let i = 0; i < this.points.length; i++) {
                    curveVertex(this.points[i].x, this.points[i].y);
                }
                curveVertex(this.points[0].x, this.points[0].y);
                curveVertex(this.points[1].x, this.points[1].y);
                endShape();
            }
        }

        // === p5.js Core Functions === //

        function setup() {
            const container = document.getElementById('p5-canvas-placeholder');
            const canvasSize = min(container.clientWidth, windowHeight * 0.7);
            const canvas = createCanvas(canvasSize, canvasSize);
            canvas.parent('p5-canvas-placeholder');
            colorMode(HSB, 360, 100, 100, 1);
            bgColor = color(30, 12, 93);
            background(bgColor); 
            setupControls();
        }
        
        function setupControls() {
            const sliders = document.querySelectorAll('input[type="range"]');
            sliders.forEach(slider => {
                slider.addEventListener('input', (e) => {
                    const id = e.target.id;
                    const value = Number(e.target.value);
                    PARAMS[id] = value;
                    const valueSpan = document.getElementById(`${id}-value`);
                    if (valueSpan) {
                         valueSpan.textContent = value.toFixed(id.includes('Amount') || id.includes('Width') ? 2 : 0);
                    }
                    updateSliderTrack(e.target);
                });
                updateSliderTrack(slider);
                const initialValueSpan = document.getElementById(`${slider.id}-value`);
                if(initialValueSpan) {
                     initialValueSpan.textContent = Number(slider.value).toFixed(slider.id.includes('Amount') || slider.id.includes('Width') ? 2 : 0);
                }
            });

            document.getElementById('clear-btn').addEventListener('click', () => { allLoops = []; background(bgColor); });
            
            const pauseBtn = document.getElementById('pause-btn');
            pauseBtn.addEventListener('click', () => {
                isPaused = !isPaused;
                if (isPaused) { noLoop(); pauseBtn.textContent = 'Play'; } else { loop(); pauseBtn.textContent = 'Pause'; }
            });
        }
        
        function updateSliderTrack(slider) {
            const min = slider.min || 0; const max = slider.max || 100; const value = slider.value;
            const progress = ((value - min) / (max - min)) * 100;
            slider.style.setProperty('--range-progress', `${progress}%`);
        }

        function draw() {
            background(30, 12, 93, 0.1); 
            let boundary = new Rectangle(width / 2, height / 2, width / 2, height / 2);
            quadtree = new QuadTree(boundary, 4);
            for (let loop of allLoops) {
                for (let p of loop.points) {
                    quadtree.insert(new Point(p.x, p.y));
                }
            }
            for (let loop of allLoops) { loop.update(); loop.display(); }
            noiseOffset += 0.002;
        }
        
        function mousePressed() {
            if (isPaused) return; 
            if (mouseX >= 0 && mouseX <= width && mouseY >= 0 && mouseY <= height) {
                 allLoops.push(new AnthozoaLoop(mouseX, mouseY));
            }
        }

        function windowResized() {
            const container = document.getElementById('p5-canvas-placeholder');
            const canvasSize = min(container.clientWidth, windowHeight * 0.7);
            resizeCanvas(canvasSize, canvasSize);
            background(bgColor);
        }

    </script>
</body>
</html>
